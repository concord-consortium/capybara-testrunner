#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), '../lib')

require 'trollop'  # For processing command-line options
require 'fileutils'
require 'json'

require 'transform-results'
require 'results-writer'
require 'yaml'

# Process command-line options
@options = Trollop::options do
  opt :runner, "Browser runner", :short => 'b', :type => String, :default => "capybara"

  # capybara specific
  opt :driver, "Capybara driver", :short => 'd', :type => String, :default => "selenium"

  # sauce labs specific
  opt :tunnel, "Start Sauce Connect Tunnel", :short => 'c', :default => false

  # look for an environment variable so the port can be changed depending on
  # the ci node that is running it
  opt :sc_server_port, "SC Server Port", :short => 'p', :type => :int, :default => (ENV['SC_SERVER_PORT'] || '4020').to_i
  opt :sc_server_host, "SC Server Host", :short => 's', :type => :string, :default => "localhost"

  opt :root_dir, "Root directory", :short => 'r', :type => :string, :default => ".."
  opt :tests_dir, "Tests directory", :short => 't', :type => :string, :default => "{apps,frameworks}"
  opt :exclude_dir, "Exclude test directory", :short => 'x', :type => :string, :multi => true

  opt :results_dir, "Results directory", :short => 'o', :type => :string, :default => "results"
  opt :junit, "Output JUnit XML", :short => 'j', :default => true
  opt :image, 'Save a png snapshot of the test page', :short => 'i', :default => false
  opt :html, 'Save an html snapshot of the test page', :short => 'h', :default => false

  opt :quiet, 'Quiet mode. Do not print messages while running', :short => 'q', :default => false
end

Trollop::die :image, "can only be enabled if using the selenium driver (you're using: #{@options[:driver]})" if @options[:image] && @options[:driver] != "selenium"

# check if DISPLAY environment variable is set on linux
if RUBY_PLATFORM =~ /linux/ and ENV['DISPLAY'].nil?
  Trollop::die "When running on linux the DISPLAY variable needs to be set to a valid X display"
end

FileUtils.mkdir_p @options[:results_dir]

@app_host = "http://#{@options[:sc_server_host]}:#{@options[:sc_server_port]}"
@browser = case @options[:runner]
when "capybara" then
  require 'capybara-runner'
  CapybaraRunner.new(@options[:driver].to_sym, @app_host)
when "selenium-rc" then
  require 'selenium-rc-runner'
  SeleniumRCRunner.new(@app_host, 'localhost', '*safari')
when "sauce" then
  require 'sauce-runner'
  SauceRunner.new(@app_host, File.dirname(__FILE__), @options[:tunnel])
end

@jasmine_results_script = File.read(File.join(File.dirname(__FILE__), '..', 'js', 'get_jasmine_results.js'))

# Find all subfolders, of folders named /tests/ under @options[:root_dir]/@options[:tests_dir], which contain
# actual javascript files. Exclude folders in tmp/** and @options[:exclude_dir]. FIXME: untested.

excludes   = @options[:exclude_dir] + [File.join("tmp","**")]
test_paths = Dir.glob File.join(@options[:root_dir], @options[:tests_dir], "**", "tests", "**", "*.js")
test_paths.reject! { |test_path|
  excludes.any? { |exclude| File.fnmatch? File.join(@options[:root_dir], exclude), test_path }
}
test_folders = test_paths.map { |test_path| File.split(test_path)[0] }.uniq

results_dir = @options[:results_dir]

# captured group 'stripped_path' strips everything up to and including leftmost instance of 'apps/' or 'frameworks/'
STRIP_RE = %r{

  (?<stripped_path> .* ){0}

  ^.*?frameworks/\g<stripped_path>$|.*?apps/\g<stripped_path>$
}x

SPLIT_RE = %r{

  (?<url_base>               .*? ){0}
  (?<optional_trailing_path> /[^/]+ ){0}
  (?<path_to_test>           tests\g<optional_trailing_path>* ){0}

  ^\g<url_base>/\g<path_to_test>$
}x

testURLs = test_folders.map { |folder|
  puts "will gather tests from folder #{folder}" unless @options[:quiet]

  path = folder.gsub!(File::SEPARATOR, '/')

  m = STRIP_RE.match path
  if m.nil? then
    puts "Can't find either apps/ or frameworks/ in path #{folder}"
    next
  end
  path = m['stripped_path']

  path.gsub! 'apps/', ''
  path.gsub! 'frameworks/', ''

  m = SPLIT_RE.match path
  if m.nil? then
    puts "Can't find tests/ in path #{folder}"
    next
  end

  url_base     = m['url_base']
  path_to_test = m['path_to_test']

  { :url               => "/static/#{url_base}/en/current/#{path_to_test}.html",
    :results_file      => File.join( results_dir, "#{url_base}-#{path_to_test}-junit.xml".gsub('/', '-') ),
    :results_html_file => File.join( results_dir, "#{url_base}-#{path_to_test}-page.html".gsub('/', '-') ),
    :results_png_file  => File.join( results_dir, "#{url_base}-#{path_to_test}-page.png".gsub('/', '-') ),
  }
}

def save_results_xml(url, results, results_type)
  File.open(url[:results_file], 'w') do |file|
    jUnitXML = nil
    case results_type
    when :qunit
      jUnitXML = TransformResults.from_qunit(results)
    when :jasmine
      jUnitXML = TransformResults.from_jasmine(results)
    end
    ResultsWriter.write(jUnitXML, file) unless jUnitXML.nil?
  end
  #uncomment this to save results for quicker testing of the transform
  #puts results.to_yaml
end

def save_page_png(file_path)
  @browser.save_screenshot(file_path)
end

def save_page_html(file_path)
  # FIXME How do we get the result html without re-running the tests?
  # one method: get the current DOM and any script elements. this is possibly too aggressive
  html = @browser.body.gsub(/<script.*?<\/script>/m, '')
  File.open(file_path, 'w') do |file|
    file.write html
    file.flush
  end
end

def wait_for_results(start, results_cmd, finished_property)
  results = nil
  while Time.now < (start + 300)
    results = @browser.js_eval(results_cmd)
    print "."
    break if results[finished_property]
    sleep 0.2
  end
  return results
end

testURLs.each{|url|
  print "visiting #{url[:url]}..." unless @options[:quiet]
  @browser.open(url[:url])
  print "visited\n" unless @options[:quiet]
  print "waiting for tests to finish"
  start = Time.now
  results = nil
  results_type = :qunit
  begin
    results = wait_for_results(start, 'CoreTest.plan.results', 'finish')
  rescue Selenium::WebDriver::Error::UnexpectedJavascriptError
    results_type = :jasmine
    results = wait_for_results(start, @jasmine_results_script, 'finished')
  end

  puts "(#{Time.now - start} seconds)"
  save_results_xml(url, results, results_type) if @options[:junit]
  save_page_png(url[:results_png_file]) if @options[:image]
  save_page_html(url[:results_html_file]) if @options[:html]
}

@browser.close
